{"version":3,"sources":["../../../../../src/features/commenting/hooks/editor/useCommentMarks.ts"],"sourcesContent":["'use client'\n\nimport type { LexicalEditor, NodeKey } from '@payloadcms/richtext-lexical/lexical'\n\nimport {\n  $getNodeByKey,\n  $getSelection,\n  $isRangeSelection,\n  $isTextNode,\n} from '@payloadcms/richtext-lexical/lexical'\nimport {\n  $createMarkNode,\n  $getMarkIDs,\n  $isMarkNode,\n  MarkNode,\n} from '@payloadcms/richtext-lexical/lexical/mark'\nimport { mergeRegister, registerNestedElementResolver } from '@payloadcms/richtext-lexical/lexical/utils'\nimport { useEffect, useMemo } from 'react'\n\nimport type { MarkNodeMapType } from '../../types/core.js'\n\n/**\n * Hook for handling comment marks in the editor\n * @param editor The Lexical editor instance\n * @param setActiveIDs Function to set active comment IDs\n * @param setActiveAnchorKey Function to set active anchor key\n * @returns Map of mark node keys to IDs\n */\nexport function useCommentMarks(\n  editor: LexicalEditor,\n  setActiveIDs: (ids: string[]) => void,\n  setActiveAnchorKey: (key: NodeKey | null) => void\n): MarkNodeMapType {\n  // Create a map to track mark nodes\n  const markNodeMap = useMemo<MarkNodeMapType>(() => {\n    return new Map()\n  }, [])\n\n  useEffect(() => {\n    const markNodeKeysToIDs: Map<NodeKey, Array<string>> = new Map()\n\n    return mergeRegister(\n      // Register nested element resolver for mark nodes\n      registerNestedElementResolver<MarkNode>(\n        editor,\n        MarkNode,\n        (from: MarkNode) => {\n          return $createMarkNode(from.getIDs())\n        },\n        (from: MarkNode, to: MarkNode) => {\n          // Merge the IDs\n          const ids = from.getIDs()\n          ids.forEach((id) => {\n            to.addID(id)\n          })\n        },\n      ),\n      \n      // Register mutation listener for mark nodes\n      editor.registerMutationListener(\n        MarkNode,\n        (mutations) => {\n          editor.getEditorState().read(() => {\n            for (const [key, mutation] of mutations) {\n              const node: MarkNode | null = $getNodeByKey(key)\n              let ids: NodeKey[] = []\n\n              if (mutation === 'destroyed') {\n                ids = markNodeKeysToIDs.get(key) || []\n              } else if ($isMarkNode(node)) {\n                ids = node.getIDs()\n              }\n\n              for (let i = 0; i < ids.length; i++) {\n                const id = ids[i]\n                let markNodeKeys = markNodeMap.get(id)\n                markNodeKeysToIDs.set(key, ids)\n\n                if (mutation === 'destroyed') {\n                  if (markNodeKeys !== undefined) {\n                    markNodeKeys.delete(key)\n                    if (markNodeKeys.size === 0) {\n                      markNodeMap.delete(id)\n                    }\n                  }\n                } else {\n                  if (markNodeKeys === undefined) {\n                    markNodeKeys = new Set()\n                    markNodeMap.set(id, markNodeKeys)\n                  }\n                  if (!markNodeKeys.has(key)) {\n                    markNodeKeys.add(key)\n                  }\n                }\n              }\n            }\n          })\n        },\n        { skipInitialization: false },\n      ),\n      \n      // Register update listener to track active IDs and anchor key\n      editor.registerUpdateListener(({ editorState }) => {\n        editorState.read(() => {\n          const selection = $getSelection()\n          let hasActiveIds = false\n          let hasAnchorKey = false\n\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode()\n\n            if ($isTextNode(anchorNode)) {\n              const commentIDs = $getMarkIDs(\n                anchorNode,\n                selection.anchor.offset,\n              )\n              if (commentIDs !== null) {\n                setActiveIDs(commentIDs)\n                hasActiveIds = true\n              }\n              if (!selection.isCollapsed()) {\n                setActiveAnchorKey(anchorNode.getKey())\n                hasAnchorKey = true\n              }\n            }\n          }\n          if (!hasActiveIds) {\n            setActiveIDs([])\n          }\n          if (!hasAnchorKey) {\n            setActiveAnchorKey(null)\n          }\n        })\n      }),\n    )\n  }, [editor, markNodeMap, setActiveIDs, setActiveAnchorKey])\n\n  return markNodeMap\n}\n"],"names":["$getNodeByKey","$getSelection","$isRangeSelection","$isTextNode","$createMarkNode","$getMarkIDs","$isMarkNode","MarkNode","mergeRegister","registerNestedElementResolver","useEffect","useMemo","useCommentMarks","editor","setActiveIDs","setActiveAnchorKey","markNodeMap","Map","markNodeKeysToIDs","from","getIDs","to","ids","forEach","id","addID","registerMutationListener","mutations","getEditorState","read","key","mutation","node","get","i","length","markNodeKeys","set","undefined","delete","size","Set","has","add","skipInitialization","registerUpdateListener","editorState","selection","hasActiveIds","hasAnchorKey","anchorNode","anchor","getNode","commentIDs","offset","isCollapsed","getKey"],"mappings":"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"}