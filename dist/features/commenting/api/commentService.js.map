{"version":3,"sources":["../../../../src/features/commenting/api/commentService.ts"],"sourcesContent":["'use client'\n\nimport type { CommentAPIEntity, SaveCommentRequest, UserAPIEntity } from '../types/api.js'\nimport type { Comment, Comments, Thread } from '../types/core.js'\nimport type { ICommentService } from '../types/services.js'\n\nimport { API_ENDPOINTS } from '../types/api.js'\nimport { APIUtils } from '../utils/api.js'\nimport { isCommentDuplicateInThread } from '../utils/comments.js'\nimport { withErrorHandling } from '../utils/errorHandling.js'\nimport { createComment, createThread } from '../utils/factory.js'\nimport { generatedIds } from '../utils/id.js'\nimport { getDocumentIdFromUrl } from '../utils/url.js'\n\n/**\n * Service for handling comment-related API operations\n */\nexport class CommentService implements ICommentService {\n  /**\n   * Slug of the user collection. Defaults to 'users'.\n   */\n  userCollectionSlug = 'users'\n\n  /**\n   * Extracts author email from a comment object\n   * @param author Author object or string\n   * @returns Author email\n   */\n  private getAuthorEmail(author: { email: string; id: string } | null | string | undefined): string {\n    if (!author) {return 'Unknown'}\n    if (typeof author === 'string') {return author}\n    return author.email || 'Unknown'\n  }\n\n  /**\n   * Helper method to save a comment within a thread\n   */\n  private async saveThreadComment(\n    comment: Comment,\n    thread: Thread,\n    documentId: string\n  ): Promise<boolean> {\n    return withErrorHandling(\n      async () => {\n        // Find the user ID by email\n        const userId = await this.findUserByEmail(comment.author)\n        \n        if (!userId) {\n          console.error(`Could not find user with email: ${comment.author}`)\n          return false\n        }\n        \n        const commentData: SaveCommentRequest = {\n          author: userId,\n          content: comment.content,\n          documentId,\n          quote: thread.quote,\n          range: undefined,\n          threadId: thread.id,\n        }\n        \n        // Save the comment\n        await APIUtils.post(API_ENDPOINTS.COMMENTS, commentData)\n        return true\n      },\n      `Error saving thread comment for thread ${thread.id}`,\n      false\n    )\n  }\n\n  /**\n   * Deletes all comments for a document\n   * @param documentId Document ID to delete comments for\n   * @returns True if successful, false otherwise\n   */\n  async deleteAllComments(documentId: string): Promise<boolean> {\n    return withErrorHandling(\n      async () => {\n        // Fetch all comments for this document\n        const params = {\n          'limit': '100',\n          'where[documentId][equals]': documentId\n        }\n        \n        const data = await APIUtils.getPaginated<CommentAPIEntity>(API_ENDPOINTS.COMMENTS, params)\n        \n        // Delete all comments\n        const updatePromises = data.docs.map(async (comment: CommentAPIEntity) => {\n          return APIUtils.delete(`${API_ENDPOINTS.COMMENTS}/${comment.id}`)\n        })\n        \n        // Wait for all updates to complete\n        await Promise.all(updatePromises)\n        return true\n      },\n      'Error deleting all comments',\n      false\n    )\n  }\n\n  /**\n   * Finds a user by email\n   * @param email User email to search for\n   * @returns User ID if found, null otherwise\n   */\n  async findUserByEmail(email: string): Promise<null | string> {\n    return withErrorHandling(\n      async () => {\n        const params = { 'where[email][equals]': email }\n        const userData = await APIUtils.getPaginated<UserAPIEntity>(`/api/${this.userCollectionSlug}`, params)\n        \n        // Get the first user that matches the email\n        return userData.docs && userData.docs.length > 0 ? userData.docs[0].id : null\n      },\n      `Error finding user with email ${email}`,\n      null\n    )\n  }\n\n  /**\n   * Loads comments for a document from the Payload API\n   * @param documentId Document ID to load comments for\n   * @returns Array of comments and threads\n   */\n  async loadComments(documentId: string): Promise<Comments> {\n    return withErrorHandling(\n      async () => {\n        // Clear the set of generated IDs to avoid conflicts with new IDs\n        generatedIds.clear()\n        \n        // Fetch comments from Payload API\n        const params = {\n          'depth': '2',\n          'where[documentId][equals]': documentId,\n        }\n        \n        const data = await APIUtils.getPaginated<CommentAPIEntity>(API_ENDPOINTS.COMMENTS, params)\n        \n        // Group comments by threadId\n        const threadMap = new Map<string, Comment[]>()\n        const threadResolvedMap = new Map<string, boolean>()\n        \n        // First pass: group comments by threadId\n        data.docs.forEach((comment: CommentAPIEntity) => {\n          if (!comment.threadId) {return}\n          \n          if (!threadMap.has(comment.threadId)) {\n            threadMap.set(comment.threadId, [])\n            threadResolvedMap.set(comment.threadId, true)\n          }\n\n          // Track resolved status: thread is resolved only if ALL non-deleted comments are resolved\n          if (!comment.resolved) {\n            threadResolvedMap.set(comment.threadId, false)\n          }\n          \n          // Get author email\n          const authorEmail = this.getAuthorEmail(comment.author)\n          \n          // Add the comment ID to the set of generated IDs\n          if (comment.id) {\n            generatedIds.add(comment.id)\n          }\n          \n          const commentObj = createComment(\n            comment.content,\n            authorEmail,\n            comment.id,\n            comment.createdAt ? new Date(comment.createdAt).getTime() : undefined,\n            comment.resolved || false\n          )\n          \n          // Check if this comment is already in the thread\n          const existingComments = threadMap.get(comment.threadId)!\n          const threadObj = { id: comment.threadId, type: 'thread', comments: existingComments, quote: '' } as Thread\n          \n          if (!isCommentDuplicateInThread(threadObj, commentObj)) {\n            existingComments.push(commentObj)\n          }\n        })\n        \n        // Second pass: create threads\n        const comments: Comments = []\n        \n        threadMap.forEach((threadComments, threadId) => {\n          // Find the first comment to get the quote\n          const firstComment = threadComments.find(c => !c.deleted)\n          if (!firstComment) {return}\n          \n          const commentData = data.docs.find((c: CommentAPIEntity) => c.id === firstComment.id)\n          const quote = commentData?.quote || ''\n          \n          // Add the thread ID to the set of generated IDs\n          generatedIds.add(threadId)\n          \n          const resolved = threadResolvedMap.get(threadId) || false\n          const thread = createThread(quote, threadComments, threadId, resolved)\n          comments.push(thread)\n        })\n        \n        return comments\n      },\n      'Error loading comments',\n      []\n    )\n  }\n\n  /**\n   * Resolves a thread by setting resolved: true on all its comments\n   */\n  async resolveThread(threadId: string): Promise<boolean> {\n    return withErrorHandling(\n      async () => {\n        const params = { 'where[threadId][equals]': threadId }\n        const data = await APIUtils.getPaginated<CommentAPIEntity>(API_ENDPOINTS.COMMENTS, params)\n\n        const updatePromises = data.docs.map(async (comment: CommentAPIEntity) => {\n          return APIUtils.patch(`${API_ENDPOINTS.COMMENTS}/${comment.id}`, {\n            resolved: true,\n          })\n        })\n\n        await Promise.all(updatePromises)\n        return true\n      },\n      `Error resolving thread ${threadId}`,\n      false\n    )\n  }\n\n  /**\n   * Saves a comment to the Payload API\n   * @param commentOrThread Comment or thread to save\n   * @param thread Parent thread if saving a comment within a thread\n   * @param documentId Document ID to associate the comment with\n   */\n  async saveComment(\n    commentOrThread: Comment | Thread,\n    thread?: Thread,\n    documentId?: string\n  ): Promise<boolean> {\n    return withErrorHandling(\n      async () => {\n        // Register IDs to prevent duplicates\n        if (commentOrThread.type === 'thread') {\n          generatedIds.add(commentOrThread.id)\n          for (const comment of commentOrThread.comments) {\n            generatedIds.add(comment.id)\n          }\n        } else {\n          generatedIds.add(commentOrThread.id)\n        }\n\n        // Get the document ID from the URL if not provided\n        const docId = documentId || getDocumentIdFromUrl()\n\n        // Save to Payload API\n        if (commentOrThread.type === 'thread') {\n          const threadObj = commentOrThread\n\n          // Save each comment in the thread\n          for (const comment of threadObj.comments) {\n            const success = await this.saveThreadComment(comment, threadObj, docId)\n            if (!success) {return false}\n          }\n\n          return true\n        } else if (commentOrThread.type === 'comment' && thread) {\n          // Save a comment that's part of a thread\n          return await this.saveThreadComment(commentOrThread, thread, docId)\n        }\n\n        return false\n      },\n      'Error saving comment',\n      false\n    )\n  }\n\n  /**\n   * Unresolves a thread by setting resolved: false on all its comments\n   */\n  async unresolveThread(threadId: string): Promise<boolean> {\n    return withErrorHandling(\n      async () => {\n        const params = { 'where[threadId][equals]': threadId }\n        const data = await APIUtils.getPaginated<CommentAPIEntity>(API_ENDPOINTS.COMMENTS, params)\n\n        const updatePromises = data.docs.map(async (comment: CommentAPIEntity) => {\n          return APIUtils.patch(`${API_ENDPOINTS.COMMENTS}/${comment.id}`, {\n            resolved: false,\n          })\n        })\n\n        await Promise.all(updatePromises)\n        return true\n      },\n      `Error unresolving thread ${threadId}`,\n      false\n    )\n  }\n}\n\n// Export a singleton instance\nexport const commentService = new CommentService()\n"],"names":["API_ENDPOINTS","APIUtils","isCommentDuplicateInThread","withErrorHandling","createComment","createThread","generatedIds","getDocumentIdFromUrl","CommentService","userCollectionSlug","getAuthorEmail","author","email","saveThreadComment","comment","thread","documentId","userId","findUserByEmail","console","error","commentData","content","quote","range","undefined","threadId","id","post","COMMENTS","deleteAllComments","params","data","getPaginated","updatePromises","docs","map","delete","Promise","all","userData","length","loadComments","clear","threadMap","Map","threadResolvedMap","forEach","has","set","resolved","authorEmail","add","commentObj","createdAt","Date","getTime","existingComments","get","threadObj","type","comments","push","threadComments","firstComment","find","c","deleted","resolveThread","patch","saveComment","commentOrThread","docId","success","unresolveThread","commentService"],"mappings":"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"}