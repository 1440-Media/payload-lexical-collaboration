{"version":3,"sources":["../../../src/features/commenting/store.ts"],"sourcesContent":["'use client'\n\nimport type { LexicalEditor } from '@payloadcms/richtext-lexical/lexical'\n\nimport type { Comment, CommentDeletionResult, Comments, Thread } from './types/core.js'\nimport type { CommentStoreInterface } from './types/store.js'\n\nimport { commentService } from './api/commentService.js'\nimport { isCommentDuplicateInThread, isThreadDuplicate } from './utils/comments.js'\nimport { withErrorHandling } from './utils/errorHandling.js'\nimport { cloneThread, markDeleted } from './utils/factory.js'\nimport { getDocumentIdFromUrl } from './utils/url.js'\n\n/**\n * Helper function to trigger onChange listeners\n */\nfunction triggerOnChange(commentStore: CommentStore): void {\n  const listeners = commentStore._changeListeners\n  for (const listener of listeners) {\n    listener()\n  }\n}\n\n/**\n * Store for managing comments and threads\n */\nexport class CommentStore implements CommentStoreInterface {\n  _changeListeners: Set<() => void>\n  _comments: Comments\n  _editor: LexicalEditor\n\n  constructor(editor: LexicalEditor, userCollectionSlug?: string) {\n    this._comments = []\n    this._editor = editor\n    this._changeListeners = new Set()\n    if (userCollectionSlug) {\n      commentService.userCollectionSlug = userCollectionSlug\n    }\n  }\n\n  /**\n   * Add a comment or thread to the store\n   */\n  addComment(\n    commentOrThread: Comment | Thread,\n    thread?: Thread,\n    offset?: number,\n  ): void {\n    const nextComments = Array.from(this._comments)\n\n    if (thread !== undefined && commentOrThread.type === 'comment') {\n      // Adding a comment to an existing thread\n      for (let i = 0; i < nextComments.length; i++) {\n        const comment = nextComments[i]\n        if (comment.type === 'thread' && comment.id === thread.id) {\n          const newThread = cloneThread(comment)\n          \n          // Check if this comment already exists in the thread\n          const isDuplicate = isCommentDuplicateInThread(newThread, commentOrThread)\n          \n          if (!isDuplicate) {\n            nextComments.splice(i, 1, newThread)\n            const insertOffset =\n              offset !== undefined ? offset : newThread.comments.length\n            newThread.comments.splice(insertOffset, 0, commentOrThread)\n          }\n          break\n        }\n      }\n    } else {\n      // Adding a new thread or standalone comment\n      if (commentOrThread.type === 'thread') {\n        // Check if this thread already exists\n        const isDuplicate = isThreadDuplicate(nextComments, commentOrThread)\n        \n        if (!isDuplicate) {\n          const insertOffset = offset !== undefined ? offset : nextComments.length\n          nextComments.splice(insertOffset, 0, commentOrThread)\n        }\n      } else {\n        // Adding a standalone comment (not in a thread)\n        const insertOffset = offset !== undefined ? offset : nextComments.length\n        nextComments.splice(insertOffset, 0, commentOrThread)\n      }\n    }\n    this._comments = nextComments\n    triggerOnChange(this)\n  }\n\n  /**\n   * Delete all comments and threads from the store\n   */\n  deleteAllComments(): void {\n    this._comments = []\n    triggerOnChange(this)\n  }\n\n  /**\n   * Delete a comment or thread from the store\n   */\n  deleteCommentOrThread(\n    commentOrThread: Comment | Thread,\n    thread?: Thread,\n  ): CommentDeletionResult | null {\n    const nextComments = Array.from(this._comments)\n    let commentIndex: null | number = null\n\n    if (thread !== undefined) {\n      for (let i = 0; i < nextComments.length; i++) {\n        const nextComment = nextComments[i]\n        if (nextComment.type === 'thread' && nextComment.id === thread.id) {\n          const newThread = cloneThread(nextComment)\n          nextComments.splice(i, 1, newThread)\n          const threadComments = newThread.comments\n          commentIndex = threadComments.indexOf(commentOrThread as Comment)\n          threadComments.splice(commentIndex, 1)\n          break\n        }\n      }\n    } else {\n      commentIndex = nextComments.indexOf(commentOrThread)\n      nextComments.splice(commentIndex, 1)\n    }\n    this._comments = nextComments\n    triggerOnChange(this)\n\n    if (commentOrThread.type === 'comment') {\n      return {\n        index: commentIndex as number,\n        markedComment: markDeleted(commentOrThread),\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Get all comments and threads\n   */\n  getComments(): Comments {\n    return this._comments\n  }\n\n  /**\n   * Load comments for a document from the Payload API\n   */\n  async loadComments(documentId: string): Promise<void> {\n    return withErrorHandling(\n      async () => {\n        // Clear existing comments\n        this._comments = []\n        \n        // Load comments from the API service\n        const comments = await commentService.loadComments(documentId)\n        \n        // Update the store with the loaded comments\n        this._comments = comments\n        \n        // Notify listeners\n        triggerOnChange(this)\n      },\n      'Error loading comments',\n      undefined\n    )\n  }\n\n  /**\n   * Register a callback to be called when the store changes\n   */\n  registerOnChange(onChange: () => void): () => void {\n    const changeListeners = this._changeListeners\n    changeListeners.add(onChange)\n    return () => {\n      changeListeners.delete(onChange)\n    }\n  }\n\n  /**\n   * Resolve or unresolve a thread\n   */\n  async resolveThread(threadId: string, resolved: boolean): Promise<boolean> {\n    return withErrorHandling(\n      async () => {\n        // Update local store\n        this._comments = this._comments.map((item) => {\n          if (item.type === 'thread' && item.id === threadId) {\n            const newThread = cloneThread(item)\n            newThread.resolved = resolved\n            return newThread\n          }\n          return item\n        })\n        triggerOnChange(this)\n\n        // Persist to API\n        return resolved\n          ? await commentService.resolveThread(threadId)\n          : await commentService.unresolveThread(threadId)\n      },\n      `Error ${resolved ? 'resolving' : 'unresolving'} thread ${threadId}`,\n      false\n    )\n  }\n\n  /**\n   * Save a comment or thread to the Payload API\n   */\n  async saveComment(\n    commentOrThread: Comment | Thread,\n    thread?: Thread,\n  ): Promise<void> {\n    return withErrorHandling(\n      async () => {\n        // Add to local store first for immediate feedback\n        this.addComment(commentOrThread, thread)\n        \n        // Get the document ID from the URL\n        const documentId = getDocumentIdFromUrl()\n        \n        // Save to the API service\n        await commentService.saveComment(commentOrThread, thread, documentId)\n      },\n      'Error saving comment',\n      undefined\n    )\n  }\n}\n\n// Export the hook from its dedicated file\nexport { useCommentStore } from './hooks/useCommentStore.js'\n"],"names":["commentService","isCommentDuplicateInThread","isThreadDuplicate","withErrorHandling","cloneThread","markDeleted","getDocumentIdFromUrl","triggerOnChange","commentStore","listeners","_changeListeners","listener","CommentStore","_comments","_editor","constructor","editor","userCollectionSlug","Set","addComment","commentOrThread","thread","offset","nextComments","Array","from","undefined","type","i","length","comment","id","newThread","isDuplicate","splice","insertOffset","comments","deleteAllComments","deleteCommentOrThread","commentIndex","nextComment","threadComments","indexOf","index","markedComment","getComments","loadComments","documentId","registerOnChange","onChange","changeListeners","add","delete","resolveThread","threadId","resolved","map","item","unresolveThread","saveComment","useCommentStore"],"mappings":"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"}