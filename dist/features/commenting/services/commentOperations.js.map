{"version":3,"sources":["../../../../src/features/commenting/services/commentOperations.ts"],"sourcesContent":["'use client'\n\nimport type { LexicalEditor, RangeSelection } from '@payloadcms/richtext-lexical/lexical'\nimport type {\n  MarkNode} from '@payloadcms/richtext-lexical/lexical/mark';\n\nimport {\n  $getNodeByKey,\n  $isRangeSelection,\n} from '@payloadcms/richtext-lexical/lexical'\nimport {\n  $isMarkNode,\n  $unwrapMarkNode,\n  $wrapSelectionInMarkNode\n} from '@payloadcms/richtext-lexical/lexical/mark'\n\nimport type { CommentStore } from '../store.js'\nimport type { CommentAPIEntity } from '../types/api.js'\nimport type { Comment, CommentDeletionResult, MarkNodeMapType, Thread } from '../types/core.js'\nimport type { ICommentOperations } from '../types/services.js'\n\nimport { commentService } from '../api/commentService.js'\nimport { API_ENDPOINTS } from '../types/api.js'\nimport { APIUtils } from '../utils/api.js'\nimport { withErrorHandling } from '../utils/errorHandling.js'\nimport { getDocumentIdFromUrl } from '../utils/url.js'\n\n/**\n * Service for handling comment operations\n */\nexport class CommentOperations implements ICommentOperations {\n  /**\n   * Delete all comments for the current document\n   * @param commentStore The comment store instance\n   * @param editor The Lexical editor instance\n   * @param markNodeMap Map of mark node keys to IDs\n   * @param saveDocumentCallback Optional callback to save the document after deletion\n   */\n  async deleteAllComments(\n    commentStore: CommentStore,\n    editor: LexicalEditor,\n    markNodeMap: MarkNodeMapType,\n    saveDocumentCallback?: () => Promise<boolean | void>\n  ): Promise<boolean> {\n    return withErrorHandling(\n      async () => {\n        // Get the document ID from the URL\n        const documentId = getDocumentIdFromUrl()\n        \n        // Delete all comments from the database\n        const success = await commentService.deleteAllComments(documentId)\n        \n        if (success) {\n          // Clear comments from the store\n          commentStore.deleteAllComments()\n          \n          // Remove all comment marks from the editor\n          editor.update(() => {\n            // Collect all mark node keys\n            const allMarkNodeKeys = new Set<string>()\n            markNodeMap.forEach((keys) => {\n              keys.forEach((key) => allMarkNodeKeys.add(key))\n            })\n            \n            // Unwrap all mark nodes\n            allMarkNodeKeys.forEach((key) => {\n              const node = $getNodeByKey(key)\n              if ($isMarkNode(node)) {\n                $unwrapMarkNode(node)\n              }\n            })\n          })\n          \n          // Save the document after removing all comment marks\n          if (saveDocumentCallback) {\n            await saveDocumentCallback()\n          }\n        }\n        \n        return success\n      },\n      'Error deleting all comments',\n      false\n    )\n  }\n\n  /**\n   * Delete a comment or thread\n   * @param commentStore The comment store instance\n   * @param editor The Lexical editor instance\n   * @param markNodeMap Map of mark node keys to IDs\n   * @param comment The comment or thread to delete\n   * @param thread The parent thread (if deleting a comment within a thread)\n   * @param saveDocumentCallback Optional callback to save the document after deletion\n   * @returns The deletion info or null\n   */\n  async deleteCommentOrThread(\n    commentStore: CommentStore,\n    editor: LexicalEditor,\n    markNodeMap: MarkNodeMapType,\n    comment: Comment | Thread,\n    thread?: Thread,\n    saveDocumentCallback?: () => Promise<boolean | void>\n  ): Promise<CommentDeletionResult | null> {\n    return withErrorHandling(\n      async () => {\n        if (comment.type === 'comment') {\n          const deletionInfo = commentStore.deleteCommentOrThread(\n            comment,\n            thread,\n          )\n          if (!deletionInfo) {\n            return null\n          }\n          const { index, markedComment } = deletionInfo\n          \n          // Delete from the database\n          await APIUtils.delete(`${API_ENDPOINTS.COMMENTS}/${comment.id}`)\n          \n          commentStore.addComment(markedComment, thread, index)\n          return deletionInfo\n        } else {\n          commentStore.deleteCommentOrThread(comment)\n          \n          // Delete all comments in the thread from the database\n          const threadId = comment.id\n          const params = { 'where[threadId][equals]': threadId }\n          const data = await APIUtils.getPaginated<CommentAPIEntity>(API_ENDPOINTS.COMMENTS, params)\n\n          if (data.docs && Array.isArray(data.docs)) {\n            const deletePromises = data.docs.map(async (threadComment: CommentAPIEntity) => {\n              return APIUtils.delete(`${API_ENDPOINTS.COMMENTS}/${threadComment.id}`)\n            })\n\n            await Promise.all(deletePromises)\n          }\n          \n          // Remove ids from associated marks\n          const id = thread !== undefined ? thread.id : comment.id\n          const markNodeKeys = markNodeMap.get(id)\n          \n          if (markNodeKeys !== undefined) {\n            // Do async to avoid causing a React infinite loop\n            setTimeout(async () => {\n              editor.update(() => {\n                for (const key of markNodeKeys) {\n                  const node: MarkNode | null = $getNodeByKey(key)\n                  if ($isMarkNode(node)) {\n                    node.deleteID(id)\n                    if (node.getIDs().length === 0) {\n                      $unwrapMarkNode(node)\n                    }\n                  }\n                }\n              })\n              \n              // Save the document after removing comment marks\n              if (saveDocumentCallback) {\n                await saveDocumentCallback()\n              }\n            })\n          }\n          \n          return null\n        }\n      },\n      'Error deleting comment or thread',\n      null\n    )\n  }\n\n  /**\n   * Resolve or unresolve a thread\n   */\n  async resolveThread(\n    commentStore: CommentStore,\n    editor: LexicalEditor,\n    markNodeMap: MarkNodeMapType,\n    thread: Thread,\n    resolved: boolean,\n  ): Promise<boolean> {\n    return withErrorHandling(\n      async () => {\n        const success = await commentStore.resolveThread(thread.id, resolved)\n        if (!success) {return false}\n\n        // Update mark node DOM classes\n        markNodeMap.get(thread.id)?.forEach((key) => {\n          editor.getElementByKey(key)?.classList.toggle('resolved', resolved)\n        })\n\n        return true\n      },\n      `Error ${resolved ? 'resolving' : 'unresolving'} thread ${thread.id}`,\n      false\n    )\n  }\n\n  /**\n   * Submit a new comment or thread\n   * @param commentStore The comment store instance\n   * @param editor The Lexical editor instance\n   * @param commentOrThread The comment or thread to add\n   * @param isInlineComment Whether this is an inline comment\n   * @param thread The parent thread (if adding a comment to a thread)\n   * @param selection The current selection (for inline comments)\n   * @param saveDocumentCallback Optional callback to save the document after adding the comment\n   */\n  async submitAddComment(\n    commentStore: CommentStore,\n    editor: LexicalEditor,\n    commentOrThread: Comment | Thread,\n    isInlineComment: boolean,\n    thread?: Thread,\n    selection?: null | RangeSelection,\n    saveDocumentCallback?: () => Promise<boolean | void>\n  ): Promise<void> {\n    return withErrorHandling(\n      async () => {\n        // Use saveComment instead of addComment to persist to database\n        await commentStore.saveComment(commentOrThread, thread)\n        \n        if (isInlineComment && selection) {\n          editor.update(() => {\n            if ($isRangeSelection(selection)) {\n              const isBackward = selection.isBackward()\n              const id = commentOrThread.id\n\n              // Wrap content in a MarkNode\n              $wrapSelectionInMarkNode(selection, isBackward, id)\n            }\n          })\n          \n          // Save the document after adding a comment\n          if (saveDocumentCallback) {\n            await saveDocumentCallback()\n          }\n        }\n      },\n      'Error submitting comment',\n      undefined\n    )\n  }\n}\n\n// Export a singleton instance\nexport const commentOperations = new CommentOperations()\n"],"names":["$getNodeByKey","$isRangeSelection","$isMarkNode","$unwrapMarkNode","$wrapSelectionInMarkNode","commentService","API_ENDPOINTS","APIUtils","withErrorHandling","getDocumentIdFromUrl","CommentOperations","deleteAllComments","commentStore","editor","markNodeMap","saveDocumentCallback","documentId","success","update","allMarkNodeKeys","Set","forEach","keys","key","add","node","deleteCommentOrThread","comment","thread","type","deletionInfo","index","markedComment","delete","COMMENTS","id","addComment","threadId","params","data","getPaginated","docs","Array","isArray","deletePromises","map","threadComment","Promise","all","undefined","markNodeKeys","get","setTimeout","deleteID","getIDs","length","resolveThread","resolved","getElementByKey","classList","toggle","submitAddComment","commentOrThread","isInlineComment","selection","saveComment","isBackward","commentOperations"],"mappings":"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"}