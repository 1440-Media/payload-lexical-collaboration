{"version":3,"sources":["../../../../src/features/commenting/services/documentService.ts"],"sourcesContent":["'use client'\n\nimport type { LexicalEditor } from '@payloadcms/richtext-lexical/lexical'\n\nimport type { IDocumentService } from '../types/services.js'\n\nimport { APIUtils } from '../utils/api.js'\nimport { withErrorHandling } from '../utils/errorHandling.js'\nimport { getCollectionFromUrl, getDocumentApiEndpoint, getDocumentIdFromUrl } from '../utils/url.js'\n\n/**\n * Service for handling document-related operations\n */\n\n/**\n * Type for rich text field value\n */\ntype RichTextField = {\n  root?: unknown\n  type?: string\n  version?: unknown\n}\n\n/**\n * Type for document data returned from the API\n */\ntype DocumentData = Record<string, unknown>\nexport class DocumentService implements IDocumentService {\n  /**\n   * Check if a document exists in the database\n   * @param documentId The document ID to check\n   * @returns True if the document exists, false otherwise\n   */\n  async checkIfDocumentExists(documentId: string): Promise<boolean> {\n    return withErrorHandling(\n      async () => {\n        // Get the document ID from the URL or props\n        const docId = documentId || getDocumentIdFromUrl()\n        \n        // Get the collection name from the URL path\n        const collection = getCollectionFromUrl()\n        if (!collection) {\n          return false\n        }\n        \n        // Check if document exists by making a GET request\n        const response = await fetch(getDocumentApiEndpoint(collection, docId))\n        return response.ok\n      },\n      'Error checking if document exists',\n      false\n    )\n  }\n\n  /**\n   * Detect the rich text field name in a document\n   * @param collection The collection name\n   * @param docId The document ID\n   * @returns The detected field name or 'content' as default\n   */\n  async detectRichTextField(collection: string, docId: string): Promise<string> {\n    return withErrorHandling(\n      async () => {\n        let fieldName = 'content' // Default field name\n        \n        const endpoint = getDocumentApiEndpoint(collection, docId)\n        const docData = await APIUtils.get<DocumentData>(endpoint)\n        \n        // Look for fields that might be rich text fields\n        const possibleFieldNames = Object.keys(docData).filter(key => {\n          // Check if the field value is an object and has properties that suggest it's a rich text field\n          const value = docData[key]\n          if (typeof value !== 'object' || value === null) {\n            return false\n          }\n          \n          // Type assertion to check for rich text field properties\n          const richTextField = value as RichTextField\n          return !!(richTextField.root || richTextField.type === 'root' || richTextField.version)\n        })\n        \n        if (possibleFieldNames.length > 0) {\n          // Use the first field that looks like a rich text field\n          fieldName = possibleFieldNames[0]\n        }\n        \n        return fieldName\n      },\n      'Error fetching document to determine field name',\n      'content' // Default field name as fallback\n    )\n  }\n\n  /**\n   * Save the document content\n   * @param editor The Lexical editor instance\n   * @param documentId The document ID to save\n   * @returns True if the document was saved successfully, false otherwise\n   */\n  async saveDocument(editor: LexicalEditor, documentId: string): Promise<boolean> {\n    return withErrorHandling(\n      async () => {\n        // Get the document ID from the URL or props\n        const docId = documentId || getDocumentIdFromUrl()\n        \n        // Get the collection name from the URL path\n        const collection = getCollectionFromUrl()\n        if (!collection) {\n          return false\n        }\n        \n        // Detect the field name\n        const fieldName = await this.detectRichTextField(collection, docId)\n        \n        // Get the current editor state as JSON\n        const editorState = editor.getEditorState()\n        const editorStateJSON = JSON.stringify(editorState.toJSON())\n        \n        // Create the update payload with the detected field name\n        const updatePayload = {\n          [fieldName]: editorStateJSON\n        }\n        \n        // Make an API call to update the document\n        const endpoint = getDocumentApiEndpoint(collection, docId)\n        await APIUtils.patch(endpoint, updatePayload)\n        \n        return true\n      },\n      'Error saving document',\n      false\n    )\n  }\n}\n\n// Export a singleton instance\nexport const documentService = new DocumentService()\n"],"names":["APIUtils","withErrorHandling","getCollectionFromUrl","getDocumentApiEndpoint","getDocumentIdFromUrl","DocumentService","checkIfDocumentExists","documentId","docId","collection","response","fetch","ok","detectRichTextField","fieldName","endpoint","docData","get","possibleFieldNames","Object","keys","filter","key","value","richTextField","root","type","version","length","saveDocument","editor","editorState","getEditorState","editorStateJSON","JSON","stringify","toJSON","updatePayload","patch","documentService"],"mappings":"AAAA;AAMA,SAASA,QAAQ,QAAQ,kBAAiB;AAC1C,SAASC,iBAAiB,QAAQ,4BAA2B;AAC7D,SAASC,oBAAoB,EAAEC,sBAAsB,EAAEC,oBAAoB,QAAQ,kBAAiB;AAmBpG,OAAO,MAAMC;IACX;;;;GAIC,GACD,MAAMC,sBAAsBC,UAAkB,EAAoB;QAChE,OAAON,kBACL;YACE,4CAA4C;YAC5C,MAAMO,QAAQD,cAAcH;YAE5B,4CAA4C;YAC5C,MAAMK,aAAaP;YACnB,IAAI,CAACO,YAAY;gBACf,OAAO;YACT;YAEA,mDAAmD;YACnD,MAAMC,WAAW,MAAMC,MAAMR,uBAAuBM,YAAYD;YAChE,OAAOE,SAASE,EAAE;QACpB,GACA,qCACA;IAEJ;IAEA;;;;;GAKC,GACD,MAAMC,oBAAoBJ,UAAkB,EAAED,KAAa,EAAmB;QAC5E,OAAOP,kBACL;YACE,IAAIa,YAAY,UAAU,qBAAqB;;YAE/C,MAAMC,WAAWZ,uBAAuBM,YAAYD;YACpD,MAAMQ,UAAU,MAAMhB,SAASiB,GAAG,CAAeF;YAEjD,iDAAiD;YACjD,MAAMG,qBAAqBC,OAAOC,IAAI,CAACJ,SAASK,MAAM,CAACC,CAAAA;gBACrD,+FAA+F;gBAC/F,MAAMC,QAAQP,OAAO,CAACM,IAAI;gBAC1B,IAAI,OAAOC,UAAU,YAAYA,UAAU,MAAM;oBAC/C,OAAO;gBACT;gBAEA,yDAAyD;gBACzD,MAAMC,gBAAgBD;gBACtB,OAAO,CAAC,CAAEC,CAAAA,cAAcC,IAAI,IAAID,cAAcE,IAAI,KAAK,UAAUF,cAAcG,OAAO,AAAD;YACvF;YAEA,IAAIT,mBAAmBU,MAAM,GAAG,GAAG;gBACjC,wDAAwD;gBACxDd,YAAYI,kBAAkB,CAAC,EAAE;YACnC;YAEA,OAAOJ;QACT,GACA,mDACA,UAAU,iCAAiC;;IAE/C;IAEA;;;;;GAKC,GACD,MAAMe,aAAaC,MAAqB,EAAEvB,UAAkB,EAAoB;QAC9E,OAAON,kBACL;YACE,4CAA4C;YAC5C,MAAMO,QAAQD,cAAcH;YAE5B,4CAA4C;YAC5C,MAAMK,aAAaP;YACnB,IAAI,CAACO,YAAY;gBACf,OAAO;YACT;YAEA,wBAAwB;YACxB,MAAMK,YAAY,MAAM,IAAI,CAACD,mBAAmB,CAACJ,YAAYD;YAE7D,uCAAuC;YACvC,MAAMuB,cAAcD,OAAOE,cAAc;YACzC,MAAMC,kBAAkBC,KAAKC,SAAS,CAACJ,YAAYK,MAAM;YAEzD,yDAAyD;YACzD,MAAMC,gBAAgB;gBACpB,CAACvB,UAAU,EAAEmB;YACf;YAEA,0CAA0C;YAC1C,MAAMlB,WAAWZ,uBAAuBM,YAAYD;YACpD,MAAMR,SAASsC,KAAK,CAACvB,UAAUsB;YAE/B,OAAO;QACT,GACA,yBACA;IAEJ;AACF;AAEA,8BAA8B;AAC9B,OAAO,MAAME,kBAAkB,IAAIlC,kBAAiB"}